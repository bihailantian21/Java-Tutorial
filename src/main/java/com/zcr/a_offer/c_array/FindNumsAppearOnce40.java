package com.zcr.a_offer.c_array;

import java.util.HashMap;

/**
 * 40.数组中只出现一次的数
 * 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
 *
 * 如：{2,4,3,6,3,2,5,5}
 * 4 6
 * //num1,num2分别为长度为1的数组。传出参数
 * //将num1[0],num2[0]设置为返回结果
 */
public class FindNumsAppearOnce40 {


    /**
     * 使用hashMap，能够保证在O(n)的时间复杂度内找到。空间复杂度O(n)。
     */
    public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for(int i=0;i<array.length;i++){
            /*if(map.containsKey(array[i])){
                int temp = map.get(array[i]);
                temp++;
                map.put(array[i], temp);*/
            map.put(array[i],map.getOrDefault(array[i],0)+1);
            /*}else {
                map.put(array[i], 1);
            }*/
        }
        boolean first = true;
        for(Integer key: map.keySet()){
            if (map.get(key) != 1)
                continue;
            else {
                if (first){
                    num1[0] = key;
                    first = false;
                }else {
                    num2[0] = key;
                }
            }
        }
    }

        /**
         * 这题好方法是用位运算来做。
         * 与：
         * 或：
         * 非：
         * 异或运算：任何一个数异或它自己都等于0。    两个一样的是：0    两个不一样的是：1
         *
         * （1）首先，任何一个数异或自身等于0，任何一个数异或0等于自身；
         * 所以在一个数组中，如果只有一个数字出现了一次，其他出现了两次，那么我们直接全部异或一遍，最终结果就是答案；
         * （2）但是这一题的要求是有两个数字出现了一次。我们的做法是将原数组按照某种方式划分成两个子数组，
         * 使得每个子数组包含其中一个只出现一次的数字，而其他数字都成对出现两次，如何分别对两个子数组异或即可。
         * （3）按照什么方式呢划分呢?
         * 我们还是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。
         * 因为其它数字都出现了两次，在异或中全部抵消掉了。
         * 由于这两个数字肯定不一样，那么异或的结果肯定不为0，也就是说在这个结果数字的二进制表示中至少就有一位为 1。
         * （4）我们在结果数字中找到第一个为 1 的位的位置，记为第 n 位。现在我们以第 n位是不是 1 为标准把原数组中的数字分成两个子数组。
         * 第一个子数组中每个数字的第n 位都是 1，而第二个子数组中每个数字的第 n 位都是 0。
         *
         * （5）由于我们分组的标准是数字中的某一位是 1 还是 0， 那么出现了两次的数字肯定被分配到同一个子数组。
         * 因为两个相同的数字的任意一位都是相同的，我们不可能把两个相同的数字分配到两个子数组中去，于是我们已经把原数组分成了两个子数组，
         * 每个子数组都包含一个只出现一次的数字，而其他数字都出现了两次。
         *
         * 举个例子，假设输入数组{2, 4, 3, 6, 3, 2, 5, 5}。
         * 过程:
         * 每一个数字做异或运算之后，得到的结果用二进制表示是 2 (二进制0010)；
         * 根据数字的倒数第二位是不是 1 分为两个数组。第一个子数组{2, 3, 6, 3, 2}、第二个子数组{4, 5, 5}；
         * 分别对这两个子数组求异或，第一个子数组中只出现一次的数字是6，而第二个子数组中只出现一次的数字是 4。
         * 4^6
         *   0100
         * ^ 0110
         *   0010
         *
         * 2:0010
         * 4:0100
         * 3:0011
         * 6:0110
         * 3:0011
         * 2:0010
         * 5:0101
         * 5:0101
         *
         *
         * @param array
         * @param num1
         * @param num2
         */
    public void FindNumsAppearOnce2(int [] array,int num1[] , int num2[]) {
        if (array.length <= 1) {
            return;
        }
        int res = 0;
        for (int i = 0; i < array.length; i++) {
            res ^= array[i];
        }
        //到现在为止，得到的结果就是那两个只出现了一次的数的异或结果

        //然后找出结果中第一个1的位的位置       找1&1=1    找的话是从右到左找，二进制，每次向左移动就大2
        int digit = 1;
        while ((res & digit) == 0) {
            digit <<= 1;
        }
        //找到了第一个1的位置

        //然后将这个位置上为1的分为一组，将这个位置上为0的分为一组               这个位置上原本为1    所以用&的方式找
        for (int i = 0; i < array.length; i++) {
            if ((array[i] & digit) == 0) {
                num1[0] ^= array[i];  //然后逐个异或，就找出了只出现一次的结果
            } else {
                num2[0] ^= array[i];
            }
        }
    }
}
