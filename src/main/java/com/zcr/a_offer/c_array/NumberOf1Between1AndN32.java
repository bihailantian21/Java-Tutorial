package com.zcr.a_offer.c_array;


/**
 * 31.整数中出现1的次数
 * 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？
 * 为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,
 * 但是对于后面问题他就没辙了。
 * ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。
 */
public class NumberOf1Between1AndN32 {


    /**
     * 累加1~n中每个整数中出现1的次数
     *
     * 我们每次可以通过对10求余数判断整数的个位数字是不是1.
     * 如果这个数字大于10，除以10之后再判断个数数字是不是1...
     *
     * 时间：O(nlogn)
     * @param n
     * @return
     */
    public int NumberOf1Between1AndN_Solution(int n) {
        int res = 0;
        for (int i = 1; i <= n; i++) {
            res += numberOf1(i);
        }
        return res;
    }

    public int numberOf1(int n) {
        int res = 0;
        while (n > 0) {
            if (n % 10 == 1) {
                res++;
            }
            n /= 10;
        }
        return res;
    }


    /**
     * 从数字规律入手
     *
     * 输入一个整数n，求从1到n这n个整数的十进制表示中1出现的次数。例如输入12，从1到12这些整数中包含1的数字有1，10，11和12，1一共出现了5次。
     *
     * 看了《剑指Offer》上的解法，我觉得不能算好：这段解释描述有些不清晰，而且没有图，难以理解。从书中给出的实现上来看，显得有些凌乱。
     * 在这篇博客里，会给出一个我对这道题的解法，包括完整的解题思路，完整代码，时间复杂度分析，以及在leetcode和牛客网上的提交结果。
     *
     * 解题思路
     * 考虑将n的十进制的每一位单独拿出讨论，每一位的值记为weight。
     * 1) 个位
     * 从1到n，每增加1，weight就会加1，当weight加到9时，再加1又会回到0重新开始。那么weight从0-9的这种周期会出现多少次呢？这取决于n的高位是多少，看图：
     * n=534 round:53 weight:4
     * 以534为例，在从1增长到n的过程中，534的个位从0-9变化了53次，记为round。每一轮变化中，1在个位出现一次，所以一共出现了53次。
     * 再来看weight的值。weight为4，大于0，说明第54轮变化是从0-4，1又出现了1次。我们记1出现的次数为count，所以：
     * count = round+1 = 53 + 1 = 54
     * 如果此时weight为0（n=530），说明第54轮到0就停止了，那么：
     * count = round = 53
     *
     * 2) 十位
     * 对于10位来说，其0-9周期的出现次数与个位的统计方式是相同的，见图：
     * n=534 round:5 weight:3
     * 不同点在于：从1到n，每增加10（一共能增加53个10），十位的weight才会增加1，所以，一轮0-9周期内，1会出现10次（个位数上的）。即rount*10。
     * 再来看weight的值。当此时weight为3，大于1，说明第6轮出现了10次1，则：
     * count = round*10+10 = 5*10+10 = 60
     * 如果此时weight的值等于0（n=504），说明第6轮到0就停止了，所以：
     * count = round*10+10 = 5*10 = 50
     * 如果此时weight的值等于1（n=514），那么第6轮中1出现了多少次呢？很明显，这与个位数的值有关，个位数为k，第6轮中1就出现了k+1次(0-k)。我们记个位数为former，则：
     * count = round*10+former +1= 5*10+4+1 = 55
     *
     * 3) 更高位
     * 更高位的计算方式其实与十位是一致的，不再阐述。
     *
     * 4) 总结
     * 将n的各个位分为两类：个位与其它位。
     * 对个位来说：
     * 若个位大于0，1出现的次数为round*1+1
     * 若个位等于0，1出现的次数为round*1
     *
     * 对其它位来说，记每一位的权值为base，位值为weight，该位之前的数是former，举例如图：
     * n=534 round:5 weight:3 Former:4  Base:10
     * 则：
     * 若weight为0，则1出现次数为round*base
     * 若weight为1，则1出现次数为round*base+former+1
     * 若weight大于1，则1出现次数为rount*base+base
     *
     * 比如：
     * 534 = （个位1出现次数）+（十位1出现次数）+（百位1出现次数）=（53*1+1）+（5*10+10）+（0*100+100）= 214
     * 530 = （53*1）+（5*10+10）+（0*100+100） = 213
     * 504 = （50*1+1）+（5*10）+（0*100+100） = 201
     * 514 = （51*1+1）+（5*10+4+1）+（0*100+100） = 207
     * 10 = (1*1)+(0*10+0+1) = 2
     *
     * 时间复杂度分析
     * 由分析思路或者代码都可以看出，while循环的次数就是n的位数,logn（以10为底），而循环体内执行的操作都是有限次的，所以时间复杂度为O(logn)。
     *
     *
     * 再举一个栗子: 1～5246中1的个数 :
     * 1、想到每一位和1的关系，拿5246，先是个位6，个位的变化范围是0~9，而这样的变化，会有524次，所以这里有524个1，
     * 又因为最后一次有个6，所以还要加一次，所以个位的1的个数是524+1 = 525；
     * 2、再看十位，十位上的数字是4，所以同理，这个位数的上的1的个数应该是52 * 10，
     * 注意这里不是52 * 1，因为，10位上的数后面10-20之间有10个1，
     * 且最后4>1，所以还要加上10，所以十位上的1的个数是52 * 10+10 = 530。
     * 3、这里要注意如果十位上的数字是1的话，就要看个位上的数是多少了，也就是10 ~ 20之间取多少个，这时候我们只要计算n%10+1就行了。
     * 然后同理推高位，可以得到1~5246中1的个数是(524 * 1+1)+(52 * 10+10)+(5 * 100+100) +( 0 * 1000+1000) = 2655个。
     *
     *
     *
     *
     * 总结：
     * 534
     * 个数4：个位上0~9的变化，变化了53次。然后加上4前面的这个1。53+1=54。
     *       如果个数>0：+1       round*base(base=1)+1(round：轮数。个数前面所有的数)
     *              =0:         round*1
     *              (改为>=1或者<1)
     * 十位3：百位上是5的话，十位上是1；4 1；3 1；2 1；1 1。一共有5轮。每轮，当十位固定为1的话，个位上会从0~9变化10次，所以每轮10次。5*10=50.（只算了500以前的数）
     *        如果十位上>1：针对十位上为1的情况，个位上会从0~9变化10次。+10                round*base(base=10)+base
     *                =0：                                                          round*base(base=10)
     *                =1：取决于个位数是多少。针对十位上为1的情况，个位上会从0~k变化k+1次。round*base(base=10)+k+1  k=formor
     *
     * 个位、十位、百位、千位：former都是n%base
     *
     * 前面没有了，round就是0.
     *
     *
     * 5132
     *
     *        初始值        个位        十位    百位             千位
     * base:      1         1          10       100             1000
     * round:   5432       543        54         5               0
     * cur:                 2         3          1             5
     * res:               543*1     54*10       5*100           5*1000
     *                     +1        +10      +5132%100=32+1   +5132%1000=132+1
     *                    544       550        533
     *
     *
     *
     * @param n
     * @return
     */
    public int NumberOf1Between1AndN_Solution2(int n) {
        if (n <= 0) return 0;
        int res = 0;
        int cur;//cur表示当前位
        int round = n;//round表示高位
        int base = 1;// base表示当前判断的位数
        while (round > 0) {
            cur = round % 10;
            round /= 10;
            res += round * base; //先加上一开始的
            if (cur == 1)
                res += (n % base) + 1; //==1 就要看前面的了
            else if (cur > 1)
                res += base; //后面剩的，>1 还要+base
            base *= 10;
        }
        return res;
    }

}
