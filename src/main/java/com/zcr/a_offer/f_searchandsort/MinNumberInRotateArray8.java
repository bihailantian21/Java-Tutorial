package com.zcr.a_offer.f_searchandsort;

/**
 * 8、旋转数组中的最小数字
 * 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
 * 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
 * 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
 * NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。
 */
public class MinNumberInRotateArray8 {

    /**
     *      * 0,1,2,3,4,5,6,7
     *      *               7
     *      *             6
     *      *           5
     *      *         4
     *      *       3
     *      *    2
     *      *  1
     *      * 0
     *      *
     *      * 0 1 2 3 4 5 6
     *      * 4,5,6,7,0,1,2
     *      *       7
     *      *     6
     *      *   5
     *      * 4
     *      * ____________
     *      *             2
     *      *           1
     *      *         0
     *        l     m     r
     *              l m   r
     *              l r
     *
     *      *
     * 旋转后的数组可以分为两个排序了的子数组，前面子数组的元素都大于等于后面子数组的元素。
     * 。
     *
     * 用二分法：时间O(logn)
     *
     * 我们先看没有重复元素的问题(这个题目可以有重复的元素)。
     * 思路：
     * 1、我们用两个指针L,R分别指向每次判断的数组左右边界。按照题目的旋转的规则，左边界应该是大于右边界的（没有重复的元素）。
     * 2、然后找到数组的中间元素arr[mid]，arr[mid] > arr[L]，则中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面。
     * 我们可以让第一个指针L 指向中间元素（这样可以缩小查找范围）；(移动之后，第一个指针仍然位于前面的递增数组中)；
     * 3、arr[mid] < arr[L]，中间元素小于第一个元素，则中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面。
     * 我们可以让第二个指针R 指向中间元素（这样可以缩小查找范围）；(移动之后，第二个指针仍然位于后面的递增数组中)；
     * 总结：不管是移动左指针还是右指针都能够使得范围缩小到原来的一半，然后我们再用更新后的指针做新一轮的查找
     * 4、按照以上思路，第一个指针L总是指向前面递增数组的元素，第二个指针R总是指向后面递增的数组元素；
     * 最终第一个指针L将指向前面数组的最后一个元素，第二个指针R指向后面数组中的第一个元素；
     * 5、也就是说他们将指向两个相邻的元素(第一种代码思路)，而第二个指针指向的刚好是最小的元素，这就是循环的结束条件；
     *
     * 一旦发现数组中第一个元素小于最后一个数字，说明数组本身就是有序的，直接返回第0个位置上的元素。
     *
     * 以上思路解决了没有重复数字的情况，这一道题目添加上了这一要求，有了重复数字。
     * 因此这一道题目比上一道题目多了些特殊情况：
     * 我们看一组例子：{1，0，1，1，1}和{1，1， 1，0，1}都可以看成是递增排序数组{0，1，1，1，1}的旋转。
     * 这种情况下我们无法继续用上一道题目的解法，去解决这道题目。因为在这两个数组中，第一个数字，最后一个数字，中间数字都是1。
     * 第一种情况下，中间数字位于后面的子数组，第二种情况，中间数字位于前面的子数组。
     * 因此当两个指针指向的数字和中间数字相同的时候，我们无法确定中间数字1是属于前面的子数组(第一种)还是属于后面的子数组（第二种）。
     * 此时我们不得不采用顺序查找的方法
     * @param array
     * @return
     */
    public int minNumberInRotateArray(int [] array) {
        if (array == null || array.length == 0) {
            return -1;
        }
        int left = 0;
        int right = array.length - 1;
        while (array[left] >= array[right]) {
            if (right - left == 1) { //递归条件 l是前一个递增序列的最后一个元素, r是后一个递增序列的第一个元素
                return array[right];
            }
            int mid = left + (right - left) / 2;
            if (array[left] == array[mid] && array[right] == array[mid]) {
                for (int i = 1; i < array.length; i++) {
                    if (array[i] < array[i - 1])
                        return array[i];
                }
            }
            if (array[mid] >= array[left]) {
                left = mid;
            } else if (array[mid] < array[left]) {
                right = mid;
            }
        }
        return array[left];
    }

    /**
     * 时间：O(n)
     * @param array
     * @return
     */
    public int minNumberInRotateArray2(int[] array) {
        if (array.length == 0)
            return 0;
        for (int i = 1; i < array.length; i++) {
            if (array[i] < array[i - 1])
                return array[i];
        }
        return array[0];//有序，就返回最后一个
    }
}
