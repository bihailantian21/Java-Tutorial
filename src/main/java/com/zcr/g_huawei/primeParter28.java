package com.zcr.g_huawei;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;

/**
 * 素数伴侣
 * 题目描述
 * 题目描述
 * 若两个正整数的和为素数，则这两个正整数称之为“素数伴侣”，如2和5、6和13，它们能应用于通信加密。现在密码学会请你设计一个程序，从已有的N（N为偶数）个正整数中挑选出若干对组成“素数伴侣”，挑选方案多种多样，例如有4个正整数：2，5，6，13，如果将5和6分为一组中只能得到一组“素数伴侣”，而将2和5、6和13编组将得到两组“素数伴侣”，能组成“素数伴侣”最多的方案称为“最佳方案”，当然密码学会希望你寻找出“最佳方案”。
 *
 * 输入:
 *
 * 有一个正偶数N（N≤100），表示待挑选的自然数的个数。后面给出具体的数字，范围为[2,30000]。
 *
 * 输出:
 *
 * 输出一个整数K，表示你求得的“最佳方案”组成“素数伴侣”的对数。
 *
 *
 *
 * 输入描述:
 * 输入说明
 * 1 输入一个正偶数n
 * 2 输入n个整数
 *
 * 输出描述:
 * 求得的“最佳方案”组成“素数伴侣”的对数。
 *
 * 示例1
 * 输入
 * 复制
 * 4
 * 2 5 6 13
 * 输出
 * 复制
 * 2
 */
public class primeParter28 {


    /**
     * 我们把这些数分成2堆——奇数和偶数，然后在他们中间，和是素数的，连上一条边，然后做匹配。
     * ——肯定有人会说，你这个和前面的建图有什么本质不同的地方吗？
     * ——是没有，但是我们说明了得到的图一定是二分图，这是有意义的。
     * 因为对二分图的最大匹配，有一个简单很多的算法，匈牙利算法。
     *
     *
     *
     * 我们先说明一下，什么是二分图。
     * 二分图就是，你可以把图上的点分成2堆，每堆之内的点不会有边，2堆之间，才可能连边。换句话说，一条边，必定连2个来自不同堆的点。
     * 现在，对每条边，一定连一个奇数，一个偶数，点能按奇数和偶数分成两部分，刚好就是二分图嘛！
     *
     *
     *
     *
     *
     * 有关二分图匹配的匈牙利算法，具体请自行搜索，这里扯一下我个人对这个算法的理解。
     * 外层，暴力考虑左边每个点
     * 对枚举的每个左边的点，要找右边一个点来匹配。
     * 那就是对左边的点，我们看他连出去的边，或者说，能连到的右边的点
     * 有2种情况：
     * 1、右边的点没人匹配——我直接贪心匹配上去
     * 2、右边的点有人匹配——考虑把目前与这个右边的点 x 匹配的左边的点 pre[x]，重新匹配一个其他的点，如果成功了，那pre[x]原来匹配的点x就释放开了，我可以直接占领上去。
     * 最后统计匹配成功多少个左边的点就行了。
     *
     * -------------------------------------------------------------------------
     * 二分图的最大匹配、完美匹配和匈牙利算法
     * 无权二分图（unweighted bipartite graph）的最大匹配（maximum matching）和完美匹配（perfect matching），以及用于求解匹配的匈牙利算法（Hungarian Algorithm）；不讲带权二分图的最佳匹配。
     * 二分图：简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。准确地说：把一个图的顶点划分为两个不相交集 U
     * 将一个图的所有顶点划分为两个不相交集U和V，使得图中的每一条边的顶点分别属于点集合U和点集V，即同一点集中的点不构成边，这样的图叫做二分图。
     * 匹配：在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点。例如，图 3、图 4 中红色的边就是图 2 的匹配。
     * Bipartite Graph(1)  Bipartite Graph(2)  Matching  Maximum Matching
     * 我们定义匹配点、匹配边、未匹配点、非匹配边，它们的含义非常显然。例如图 3 中 1、4、5、7 为匹配点，其他顶点为未匹配点；1-5、4-7为匹配边，其他边为非匹配边。
     * 最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。图 4 是一个最大匹配，它包含 4 条匹配边。
     * 完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。图 4 是一个完美匹配。显然，完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，
     * 添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。
     * 举例来说：如下图所示，如果在某一对男孩和女孩之间存在相连的边，就意味着他们彼此喜欢。是否可能让所有男孩和女孩两两配对，
     * 使得每对儿都互相喜欢呢？图论中，这就是完美匹配问题。
     * 如果换一个说法：最多有多少互相喜欢的男孩/女孩可以配对儿？这就是最大匹配问题。
     *
     * 基本概念讲完了。求解最大匹配问题的一个算法是匈牙利算法，下面讲的概念都为这个算法服务。
     * 交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。
     * 增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。
     * 如果一条路径的首尾都是非匹配点，路径中除此之外（如果有）其他的点均是匹配点，那么这条路径就是一条增广路经
     * 例如，图 5 中的一条增广路如图 6 所示（图中的匹配点均用红色标出）：
     * 增广路有一个重要特点：非匹配边比匹配边多一条。因此，研究增广路的意义是改进匹配。只要把增广路中的匹配边和非匹配边的身份交换即可。
     * 由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目比原来多了 1 条。
     *
     * 我们可以通过不停地找增广路来增加匹配中的匹配边和匹配点。找不到增广路时，达到最大匹配（这是增广路定理）。
     * (注意前面增广路的定义：“从一个未匹配点出发，走交替路，以另一个未匹配点为结尾”，首尾都是未匹配点，说明首尾的边都是非匹配边。
     * 而又是交替路，也就是说非匹配边比匹配边多一条。那么我们完全可以把这条增广路里的匹配边和非匹配边互换（称为“交换匹配”），
     * 那么匹配边就会多出 1 条，实现了“增广”的意义。并且这样做并不会对其他边造成影响，也不破坏二分图的性质。
     *
     * 那么我们就可以一直找增广路，不断交换匹配。根据增广路定理，如果找不到了，就说明已经达到最大匹配。
     * 同样可以证明，已经匹配的点永远不会退出匹配，只会更换匹配。
     *
     * 这就是匈牙利算法最核心的部分了：一直找增广路，不断交换匹配。)
     *
     *
     * 匈牙利算法正是这么做的。在给出匈牙利算法 DFS 和 BFS 版本的代码之前，先讲一下匈牙利树。
     *
     * 匈牙利树一般由 BFS 构造（类似于 BFS 树）。从一个未匹配点出发运行 BFS（唯一的限制是，必须走交替路），直到不能再扩展为止。
     * 例如，由图 7，可以得到如图 8 的一棵 BFS 树：
     * 这棵树存在一个叶子节点为非匹配点（7 号），但是匈牙利树要求所有叶子节点均为匹配点，因此这不是一棵匈牙利树。
     * 如果原图中根本不含 7 号节点，那么从 2 号节点出发就会得到一棵匈牙利树。这种情况如图 9 所示（顺便说一句，图 8 中根节点 2 到非匹配叶子节点 7
     * 显然是一条增广路，沿这条增广路扩充后将得到一个完美匹配）。
     *
     * 下面给出匈牙利算法的 DFS 和 BFS 版本的代码：
     * 匈牙利算法
     * 1.建立有向图G，分为二分图的左右两侧
     * 2.优先选择左侧序号更小的进行匹配。
     * 3.如果左侧两个点的目标点冲突，让序号小的点选择另一个可能的目标点进行匹配。如果没有可匹配的其他点，则匹配失败。
     *
     *
     * 匈牙利算法的要点如下
     * 1.从左边第 1 个顶点开始，挑选未匹配点进行搜索，寻找增广路。
     * (1)如果经过一个未匹配点，说明寻找成功。更新路径信息，匹配边数 +1，停止搜索。
     * (2)如果一直没有找到增广路，则不再从这个点开始搜索。事实上，此时搜索后会形成一棵匈牙利树。我们可以永久性地把它从图中删去，而不影响结果。
     * 2.由于找到增广路之后需要沿着路径更新匹配，所以我们需要一个结构来记录路径上的点。DFS 版本通过函数调用隐式地使用一个栈，而 BFS 版本使用 prev 数组。
     *
     *

     * 外层，暴力考虑左边每个点
     * 对枚举的每个左边的点，要找右边一个点来匹配。
     * 那就是对左边的点，我们看他连出去的边，或者说，能连到的右边的点
     * 有2种情况：
     * 1、右边的点没人匹配——我直接贪心匹配上去
     * 2、右边的点有人匹配——考虑把目前与这个右边的点 x 匹配的左边的点 pre[x]，重新匹配一个其他的点，如果成功了，那pre[x]原来匹配的点x就释放开了，我可以直接占领上去。
     * 最后统计匹配成功多少个左边的点就行了。
     *
     * for (i=1;i<=n;i++)//左边的点（男生）
     * {
     *     memset(used,0,sizeof(used));    //这个在每一步中清空
     *     if find(i) all+=1;
     * }
     *
     * bool find(int x){
     *     int i,j;
     *     for (j=1;j<=m;j++){    //右边的点（女生）
     *         if (line[x][j]==true && used[j]==false)//如果有暧昧并且还没有标记过(这里标记的意思是这次查找曾试图改变过该妹子的归属问题，但是没有成功，所以就不用瞎费工夫了）
     *         {
     *             used[j]=1;
     *             if (girl[j]==0 || find(girl[j])) {
     *                 //名花无主或者能腾出个位置来，这里使用递归
     *                 girl[j]=x;
     *                 return true;
     *             }
     *         }
     *     }
     *     return false;
     * }
     *
     *
     * 例题
     *  P1894[USACO4.2]完美的牛栏The Perfect Stall
     *  P2071座位安排
     *  P1525关押罪犯（并查集做法）
     *  P2756飞行员配对方案问题
     *  P1129[ZJOI2007]矩阵游戏
     *  P2055[ZJOI2009]假期的宿舍
     *  P1640[SCOI2010]连续攻击游戏
     *  P1402酒店之王
     * @param args
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            int num = scanner.nextInt();
            if (num > 100) {
                break;
            }
            int[] dict = new int[num];
            ArrayList<Integer> event = new ArrayList<>();
            ArrayList<Integer> odd = new ArrayList<>();
            for (int i = 0; i < num; i++) {
                dict[i] = scanner.nextInt();
                if (dict[i] % 2 == 0) {
                    event.add(dict[i]);
                } else {
                    odd.add(dict[i]);
                }
            }

            int result = 0;
            /*for (int i = 0; i < num; i++) {
                for (int j = i + 1; j < num; j++) {
                    if (isPrime(dict[i] + dict[j])) {
                        result++;
                    }
                }
            }*/
            int[] oddMatch = new int[odd.size()];//来记录下匹配odd对应的event信息，以便于回溯这个event
            for (int i = 0; i < event.size(); i++) {//对于每个event，去找自己的odd
                int[] used = new int[odd.size()];//左边每找一个点，used都要请0，因为对于待匹配的event来说，右边的每个odd都是新鲜的
                if (find(event.get(i), used, odd, oddMatch)) {
                    result += 1;
                }
            }
            System.out.println(result);
        }
    }

    private static boolean find(Integer integer, int[] used, ArrayList<Integer> odd, int[] oddMatch) {
        for (int i = 0; i < odd.size(); i++) {
            if (isPrime(integer + odd.get(i)) && used[i] == 0) {
                used[i] = 1;
                if (oddMatch[i] == 0 || find(oddMatch[i], used, odd, oddMatch)) {
                    oddMatch[i] = integer;
                    return true;
                }
            }
        }
        return false;
    }

    private static boolean isPrime(int i) {
        if (i <= 3) {
            return true;//是质数
        }
        for (int j = 2; j < Math.sqrt(i); j++) {
            if (i % j == 0) {
                return false;//不是质数
            }
        }
        return true;
    }
}
