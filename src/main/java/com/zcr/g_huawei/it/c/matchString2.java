package com.zcr.g_huawei.it.c;


/**
 * 第一行输入一个字符串T,
 * 第二行输入一个字符串A, H*R这样的构造，H、R长度至少为1，对字符串T进行匹配，*可以匹配任意长度字符串，要求T中匹配H和R的部分不能重复使用。
 * 输出有几种匹配。
 *
 * 输入：
 * AAAXBBB
 * A*B
 * 输出：
 * 3
 * 注：有三种匹配方式：AAAXB、AAXBB、AXBBB。
 * 而AAAXB和AAAXBB就不行，因为第一个A匹配H用了两次。
 *
 *
 *
 * 比如字符A: asssddf 字符B: s*d 这个*可以当s用也可以当d用，所以情况又 sssd ssd sdd 类似于shell里的通配符的概念。
 * 一点没写有点亏啊。。瞎写点也能有分 不过过了就行
 *
 *
 *
 *
 * 第二题我是写了一个函数find，从字符串T中的第h位开始查找匹配对象（H或R)。具体实现：因为H和R是在字符串A中，一个是0到loc-1，一个是loc+1到A.size()-1，（loc是指*的位置），所以我把 A 和开始、结尾作为参数传了进去。
 * 主函数我是在一个循环里面，先找到一个匹配头H，然后找到一个匹配尾R，如果匹配到的头在尾之后，就继续找下一个尾。找到后更新s1, s2。进入下一个循环，寻找下一个头，下一个尾。
 * 第二题示例：
 * 输入：AAAXBB  A*B
 * 输出：2（AAAXB（用了第一个A和第一个B)和AAXBB（用了第二个A和第二个B))就是说每一个匹配都只能用一次。
 *
 * 输入：ABABABAB  AB*AB
 * 输出：3（ABAB(第一个和第二个AB),ABAB(第二个和第三个AB),ABAB(第三个和第四个AB))
 *
 */
public class matchString2 {
}
