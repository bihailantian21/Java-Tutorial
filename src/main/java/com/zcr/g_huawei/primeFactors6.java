package com.zcr.g_huawei;


import java.util.Scanner;

/**
 * 质子因数
 * 题目描述
 * 功能:输入一个正整数，按照从小到大的顺序输出它的所有质因子（重复的也要列举）（如180的质因子为2 2 3 3 5 ）
 *
 * 最后一个数后面也要有空格
 *
 * 输入描述:
 * 输入一个long型整数
 *
 * 输出描述:
 * 按照从小到大的顺序输出它的所有质数的因子，以空格隔开。最后一个数后面也要有空格。
 *
 * 示例1
 * 输入
 * 复制
 * 180
 * 输出
 * 复制
 * 2 2 3 3 5
 *
 *
 *
 *
 *
 *
 *
 */
public class primeFactors6 {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            long number = scanner.nextLong();
            primeFactors(number);
        }
    }


    /**
     * 就是找输入数的质因子，不用判断素数啥的
     *
     * 90
     * 2
     *
     *
     * 外层循环：是number    number/=i
     * 内层循环：是i    会被中断
     * @param number
     */
    public static void primeFactors(long number) {
        while (number != 1) {
            for (int i = 2; i <= number; i++) {
                if (number % i == 0) {
                    number /= i;
                    System.out.print(i + " ");
                    break;//中断上一轮i的循环，以便于下一轮还是从i=2开始循环
                }
            }
        }
    }

    /**
     * 1.质数知识
     * 1.1 定义
     * 质因数（素因数或质因子）在数论里是指能整除给定正整数的质数。除了1以外，两个没有其他共同质因子的正整数称为互质。
     * 因为1没有质因子，1与任何正整数（包括1本身）都是互质。正整数的因数分解可将正整数表示为一连串的质因子相乘，质因子如重复可以用指数表示。
     * 根据算术基本定理，任何正整数皆有独一无二的质因子分解式。只有一个质因子的正整数为质数。
     *
     * 每个合数都可以写成几个质数（也可称为素数）相乘的形式，这几个质数就都叫做这个合数的质因数。
     * 如果一个质数是某个数的因数，那么就说这个质数是这个数的质因数；而这个因数一定是一个质数。
     *
     * 1.2 例子
     * 1没有质因子。
     * 5只有1个质因子，5本身。（5是质数。）
     * 6的质因子是2和3。(6 = 2 × 3)
     * 2、4、8、16等只有1个质因子：2（2是质数，4 = 2，8 = 2，如此类推。）
     * 10有2个质因子：2和5。(10 = 2 × 5)
     * 就是一个数的约数，并且是质数，比如8=2×2×2，2就是8的质因数。12=2×2×3，2和3就是12的质因数。
     * 把一个式子以12=2×2×3的形式表示，叫做分解质因数。16=2×2×2×2,2就是16的质因数，把一个合数写成几个质数相乘的形式表示，这也是分解质因数。
     *
     * 分解质因数的方法是先用一个合数的最小质因数去除这个合数，得出的数若是一个质数，就写成这个合数相乘形式；若是一个合数就继续按原来的方法，直至最后是一个质数 。
     *
     * 分解质因数的有两种表示方法，除了大家最常用知道的“短除分解法”之外，还有一种方法就是“塔形分解法”。
     * 分解质因数对解决一些自然数和乘积的问题有很大的帮助，同时又为求最大公约数和最小公倍数做了重要的铺垫
     *
     * 1.4 计算方法
     * 短除法
     * 求一个数分解质因数，要从最小的质数除起，一直除到结果为质数为止。分解质因数的算式的叫短除法，和除法的性质差不多，还可以用来求多个个数的公因式：
     * 求最大公因数的一种方法，也可用来求最小公倍数。
     * 求几个数最大公因数的方法，开始时用观察比较的方法，即：先把每个数的因数找出来，然后再找出公因数，最后在公因数中找出最大公因数。
     *
     * 2 程序思路
     * 分解质因数代码：
     * 将一个正整数分解质因数。例如：输入90,打印出90=2*3*3*5。
     * 程序分析：对n进行分解质因数，应先找到一个最小的质数i，然后按下述步骤完成：
     * (1)如果这个质数恰等于n，则说明分解质因数的过程已经结束，打印出即可。
     * (2)如果n>i，但n能被i整除，则应打印出i的值（i为质因子）；并用n除以i的商,作为新的正整数i；同时i++
     * 　重复执行第一步。
     * (3)如果n不能被i整除，则用i++,重复执行第一步。
     * @param number
     *
     *
     *
     *
     *
     * 90=2*3*3*5
     * 2      45
     *        2
     *        3        15
     *                  3        5
     *                           3
     *                           4
     *                           5
     *
     *
     *
     */
    public static void primeFactors2(long number) {

    }

    /**
     * 递归的思路
     *
     * 90=2*3*3*5
     * 2     45
     *       2
     *       3      15
     *               2
     *               3       5
     *                       2
     *                       3
     *                       4
     *                       5
     * @param number
     */
    public static void primeFactors3(long number) {
        for (int i = 2; i <= number; i++) {
            if (number % i == 0) {
                System.out.print(i + " ");
                primeFactors3(number / i);
                break;//这个很重要。跳出整个循环用的！         就是每次递归后跳出整个循环。
            }
            if (i == number) {
                System.out.print(i + "");
            }
        }
    }

    /**
     * 其实最后一步特殊判断不需要
     * 90=2*3*3*5
     *      * 2     45
     *      *       2
     *      *       3      15
     *      *               2
     *      *               3       5
     *      *                       2
     *      *                       3
     *      *                       4
     *      *                       5
     * 如果能整除，就用除的结果继续除这个i，记得要切断上一个数对i的循环；如果不能整除，才将i++。
     * 外层循环：是i
     * 内层循环：是number
     * @param number
     */
    public static void primeFactors4(long number) {
        for (int i = 2; i <= number; i++) {
            if (number % i == 0) {
                System.out.print(i + " ");
                primeFactors3(number / i);
                break;//这个很重要。跳出整个循环用的！         就是每次递归后跳出整个循环。
            }
        }
    }


    /**
     * 不需要递归
     * 思路启发：
     * 根据表达式 2*2*3*3*5=180 ，我们可以想到 180/2=90=2*3*3*5 ，同样 90/2=45=3*3*5 ，直至 5/5=1。
     * 可以想到设置一个候选数pom=2开始被正整数180除，若能整除则记录，正整数转成180整除pom的得数；否则pom++，寻找下一个整除正整数的候选数。
     * 一直循环直至剩余的正整数小于pom。
     *
     * 90
     * 2      45
     *        2
     *        3    15
     *              3     5
     *                    3
     *                    4
     *                    5
     * 这个是我最终选择的答案：如果能整除，就用除的结果继续除这个i【上一个数对i的循环就断了】；如果不能整除，才将i++
     * 外层循环：是i
     * 内层循环：是number
     * @param number
     */
    public static void primeFactors5(long number) {
        int i = 2;
        while (number >= i){
            if (number % i == 0) {
                System.out.print(i + " ");
                number /= i;
            } else {
                i++;
            }
        }
    }


}
