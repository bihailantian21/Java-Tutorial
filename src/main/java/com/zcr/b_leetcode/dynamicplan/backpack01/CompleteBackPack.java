package com.zcr.b_leetcode.dynamicplan.backpack01;


/**
 * 套「完全背包」问题的公式
 * 为什么是「完全背包」问题：
 * 1、每个硬币可以使用无限次；
 * 2、硬币总额有限制；
 * 3、并且具体组合是顺序无关的，还以示例 1 为例：面值总额为 11，方案 [1, 5, 5] 和方案 [5, 1, 5] 视为同一种方案。
 *
 * 但是与「完全」背包问题不一样的地方是：
 * 1、要求恰好填满容积为 amount 的背包，重点是「恰好」、「刚刚好」，而原始的「完全背包」问题只是要求「不超过」；
 * 2、题目问的是总的硬币数最少，原始的「完全背包」问题让我们求的是总价值最多。
 *
 * 这一点可以认为是：每一个硬币有一个「占用空间」属性，并且值是固定的，固定值为 11；
 * 作为「占用空间」而言，考虑的最小化是有意义的。
 * 相当于是把「完全背包」问题的「体积」和「价值」属性调换了一下。
 *
 * 因此，这个问题的背景是「完全背包」问题，可以使用「完全背包」问题的解题思路：（「0-1 背包」问题也是这个思路）一个一个硬币去看，
 * 一点点扩大考虑的价值的范围（自底向上考虑问题的思想），其实就是在不断地做尝试和比较，实际生活中，人也是这么干的，
 * 「盗贼」拿东西也是这样的，看到一个体积小，价值大的东西，就会从背包里把占用地方大，廉价的物品换出来。
 *
 * 所以代码里：外层循环先遍历的是硬币面试，内层循环遍历的是面值总和，这是这样写的依据。
 *
 * 说明：以下代码提供的是「完全背包」问题「最终版本」的代码。建议读者按照以下路径进行学习，相信就不难理解这个代码为什么这样写了。
 *
 * 「0-1 背包」问题，二维表格的写法；
 * 「0-1 背包」问题，滚动数组的写法；
 * 「0-1 背包」问题只用一行，从后向前覆盖赋值的写法（因为只关心最后一行最后一格数值，每个单元格只参考它上一行，并且是正上方以及正上方左边的单元格数值）；
 *
 * 「完全背包」问题，二维表格的写法（最朴素的解法，枚举每个硬币可以选用的个数）；
 * 「完全背包」问题，优化了「状态转移方程」的二维表格的写法（每一行只参考了上一行正上方的数值，和当前行左边的数值）；
 * 「完全背包」问题压缩成一行的写法，正好与「0-1 背包」问题相反，「0-1 背包」问题倒着写，「完全背包」问题正着写（看看填表顺序，就明白了）。
 * （这里省略了 2 版代码，请读者自己学习背包问题的知识，将它们补上。）
 */
public class CompleteBackPack {
}
